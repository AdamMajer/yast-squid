/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	modules/Squid.ycp
 * Package:	Configuration of squid
 * Summary:	Squid settings, input and output functions
 * Authors:	Daniel Fiser <dfiser@suse.cz>
 *
 * $Id: Squid.ycp 27914 2006-02-13 14:32:08Z locilka $
 *
 * Representation of the configuration of squid.
 * Input and output routines.
 */

{

module "Squid";
textdomain "squid";

import "Progress";
import "Report";
import "Summary";
import "Message";

/**
 * Defines path used in SCR::Read/Write functions
 */
path squid_path = .etc.squid;


/**
 * Data was modified?
 */
boolean modified = false;

/**
 * Map of all configuration settings except consequential. Format:
 * $[ "parameter name" : [ list of options (rest of line) ]
 *    ...
 * ]
 */
map <string,any> settings = $[];

/**
 * List of http_ports. Format:
 * [ $["host" : "hostname",
 *     "port" : "3128",
 *     "transparent" : true],
 *     ...
 * ]
 */
list <map <string,any> > http_ports = [];

/**
 * List of acls. Format:
 * [ $[ "name" : "localhost",
 *      "type" : "src",
 *      "options" : [ non-empty list of options ]]
 *      ...
 * ]
 */
list <map <string,any> > acls = [];

/**
 * List of access control parameters. Format:
 * [ $["allow" : true,
 *     "acl" : ["acl1", "!acl2", ...] ],
 *     ...
 * ]
 */
list <map <string,any> > http_accesses = [];

/**
 * List of refresh patterns. Format:
 * [ $["regexp" : "^ftp:",
 *     "case_sensitive" : true,
 *     "min" : "12",
 *     "max" : "12",
 *     "percent" : "12"],
 *     ...
 * ]
 */
list <map <string,any> > refresh_patterns = [];


/**
 * Map of all available parameters with defalut values.
 * $[ "parameter_name" : [ list of default options ],
 *    ...
 *  ]
 */
map <string, list> parameters = $[
    "cache_dir" : ["ufs", "/var/cache/squid", "100", "16", "256"],
    "cache_mem" : ["8", "MB"],
    "cache_swap_low" : ["90"],
    "cache_swap_high" : ["95"],
    "maximum_object_size" : ["4096", "KB"],
    "minimum_object_size" : ["0", "KB"],
    "cache_replacement_policy" : ["lru"],
    "memory_replacement_policy" : ["lru"],

    "access_log" : ["/var/log/squid/access.log"],
    "cache_log" : ["/var/log/squid/cache.log"],
    "cache_store_log" : ["/var/log/squid/store.log"],
    "emulate_httpd_log" : ["off"],

    "connect_timeout" : ["2", "minutes"],
    "client_lifetime" : ["1", "day"],

    "error_directory" : ["/usr/share/squid/errors/English"],
    "cache_mgr" : ["webmaster"],
    "ftp_passive" : ["on"]
];


/**
 * Same as splitstring(), but returns only non-empty strings.
 */
list<string> split(string str, string delim)
{
    return filter(string value, splitstring(str, delim),
                {
                    //y2debug("Squid::split value: %1, size(value): %2",value, size(value));
                    return (size(value)>0);
                });
}




global boolean Modified(){
    return modified;
}


/**
 */
global boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global boolean() AbortFunction = Modified;

/**
 * Abort function
 * @return boolean return true if abort
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
    {
	return AbortFunction () == true;
    }
    return false;
}


/******* ACL *******/
global list<map<string,any> > GetACLs()
{
    return acls;
}

global map<string,any> GetACL(integer id_item)
{
    return acls[id_item]:$[];
}

global string GetACLType(integer id_item)
{
    return (acls[id_item]:$[])["type"]:"";
}

global string GetACLTypeByName(string acl_name)
{
    string ret = nil;
    foreach (map<string,any> value, acls,
        {
            if (value["name"]:"" == acl_name){
                ret = value["type"]:"";
                break;
            }
        });
    return ret;
}

global void AddACL(string name, string type, list<string> options)
{
    acls = add(acls, $[ "name" : name,
                        "type" : type,
                        "options" : options]);
}

global void ModifyACL(integer id_item, string name, string type, list<string> options)
{
    if (id_item >= 0 && id_item < size(acls)){
        acls[id_item] = $[ "name" : name,
                           "type" : type,
                           "options" : options];
    }
}

global void DelACL(integer id_item)
{
    if (id_item >= 0 && id_item < size(acls)){
        acls = remove(acls, id_item);
    }
}


/**
 * Returns number of occurences of ACL (definition lines) in config file.
 */
global integer NumACLs(integer id_item)
{
    string acl = (acls[id_item]:$[])["name"]:""; //get name of acl
    if (size(acl) == 0) return nil; //invalid id_item
    integer ret = 0;

    foreach (map<string, any> value, acls,
        {
            if (value["name"]:"" == acl)
                ret = ret + 1;
        });

    y2debug("Squid::NumACLs() - acl: %1, num: %2", acl, ret);

    return ret;
}

/**
 * Same as NumACLs but ACL is identified by name.
 */
global integer NumACLsByName(string name)
{
    integer ret = nil;
    integer i = 0;
    foreach (map<string,any> value, acls,
        {
            if (value["name"]:"" == name){
                break;
            }
            i = i + 1;
        });
    if (i < size(acls)){
        ret = NumACLs(i);
    }

    return ret;
}

/**
 * Returns list of options which use this ACL (identified by id_item).
 * It's necessary to run this function before deleting ACL to know if
 * any options are not affected.
 */
global list<string> ACLIsUsedBy(integer id_item)
{
    string acl = (GetACL(id_item))["name"]:"";
    if (size(acl) == 0) return nil; //invalid id_item

    list<string> params = [];
    list<string> ret = [];

    // options with format:
    //      option_name something ACL ACL ACL ...
    list<string> format1 = [
        "no_cache", "cache",
        "broken_vary_encoding",
        "follow_x_forwarded_for",
        //"http_access", -> cached in this module !!!
        "http_reply_access",
        "icp_access",
        "htcp_access",
        "miss_access",
        "ident_lookup_access",
        "log_access",
        "always_direct",
        "never_direct",
        "snmp_access",
        "broken_posts",
        "deny_info"
    ];
    // options with format:
    //      option_name something something ACL ACL ACL ...
    list<string> format2 = [
        "tcp_outgoing_tos",
        "tcp_outgoing_address",
        "reply_body_max_size",
        "header_access",
        "cache_peer_access",
        "access_log"
    ];

    list<string> available_options = SCR::Dir(squid_path);

    foreach (string value, (list<string>)merge(format1, format2),
        {
            if (contains(available_options, value)){
                foreach (string val, (list<string>)SCR::Read( add(squid_path, value)),
                    {
                        params = remove(split(val, " \t"), 0); // remove first param
                        if (contains(format2, value)){ // if it is format 2 remove also second param
                            if (size(params) > 1){
                                params = remove(params, 0);
                            }else{
                                break;
                            }
                        }

                        if (contains(params, acl) || contains(params, "!"+acl)){
                            ret = add(ret, value);
                            break;
                        }
                    });
            }
        });

    //http_access:
    foreach (map<string, any> value, http_accesses,
        {
            if (contains(value["acl"]:[], acl) || contains(value["acl"]:[], "!"+acl)){
                ret = add(ret, "http_access");
                break;
            }
        });

    y2debug("Squid::ACLIsUsedBy() - acl:%1, ret: %2", acl, ret);

    return ret;
}
/******* ACL END *******/

/******* HTTP_ACCESS ******/
global list<map<string,any> > GetHttpAccesses()
{
    return http_accesses;
}

global map<string,any> GetHttpAccess(integer id_item)
{
    return http_accesses[id_item]:$[];
}

global void AddHttpAccess(boolean allow, list<string> acl)
{
    http_accesses = add(http_accesses, $["allow" : allow,
                                         "acl" : acl]);
}

global void ModifyHttpAccess(integer id_item, boolean allow, list<string> acl)
{
    if (id_item >= 0 && id_item < size(http_accesses)){
        http_accesses[id_item] = $["allow" : allow,
                                   "acl" : acl];
    }
}

global void DelHttpAccess(integer id_item)
{
    if (id_item >= 0 && id_item < size(http_accesses)){
        http_accesses = remove(http_accesses, id_item);
    }
}

global void MoveHttpAccess(integer id_from, integer id_to)
{
    if (id_from >= 0 && id_from < size(http_accesses)
        && id_to >= 0 && id_to < size(http_accesses)){

        map<string,any> tmp = http_accesses[id_from]:$[];
        http_accesses[id_from] = http_accesses[id_to]:$[];
        http_accesses[id_to] = tmp;
    }
}
/******* HTTP_ACCESS END ******/

/******* SETTINGS *****/
global map<string,any> GetSettings()
{
    return settings;
}

global list<string> GetSetting(string name)
{
    return settings[name]:[];
}

global void SetSetting(string name, list value)
{
    settings[name] = value;
}

/******* SETTINGS END *****/

/**** REFRESH PATTERN ****/
global list <map<string,any> > GetRefreshPatterns()
{
    return refresh_patterns;
}

global map<string,any> GetRefreshPattern(integer id_item)
{
    return refresh_patterns[id_item]:$[];
}

global void AddRefreshPattern(string regexp, string min, string percent, string max, boolean case_sensitive)
{
    refresh_patterns = add(refresh_patterns, $[ "regexp" : regexp,
                                                "min" : min,
                                                "percent" : percent,
                                                "max" : max,
                                                "case_sensitive" : case_sensitive]);
}

global void ModifyRefreshPattern(integer id_item, string regexp, string min, string percent, string max, boolean case_sensitive)
{
    if (id_item >= 0 && id_item < size(refresh_patterns)){
        refresh_patterns[id_item] = $[ "regexp" : regexp,
                                       "min" : min,
                                       "percent" : percent,
                                       "max" : max,
                                       "case_sensitive" : case_sensitive];
    }
}

global void DelRefreshPattern(integer id_item)
{
    if (id_item >= 0 && id_item < size(refresh_patterns)){
        refresh_patterns = remove(refresh_patterns, id_item);
    }
}

global void MoveRefreshPattern(integer id_from, integer id_to)
{
    if (id_from >= 0 && id_from < size(refresh_patterns)
        && id_to >= 0 && id_to < size(refresh_patterns)){

        map<string,any> tmp = refresh_patterns[id_from]:$[];
        refresh_patterns[id_from] = refresh_patterns[id_to]:$[];
        refresh_patterns[id_to] = tmp;
    }
}
/**** REFRESH PATTERN END ****/

/**** HTTP PORT *****/
global list <map<string, any> > GetHttpPorts()
{
    return http_ports;
}

global map<string, any > GetHttpPort(integer id_item)
{
    return http_ports[id_item]:$[];
}

global void AddHttpPort(string host, string port, boolean transparent)
{
    http_ports = add(http_ports, $["host" : host,
                                   "port" : port,
                                   "transparent" : transparent]);
}

global void ModifyHttpPort(integer id_item, string host, string port, boolean transparent)
{
    if (id_item >= 0 && id_item < size(http_ports)){
        http_ports[id_item] = $["host" : host,
                                "port" : port,
                                "transparent" : transparent];
    }
}

global void DelHttpPort(integer id_item)
{
    if (id_item >= 0 && id_item < size(http_ports)){
        http_ports = remove(http_ports, id_item);
    }
}
/**** HTTP PORT END *****/

/**
 * Verify and repair list of ACLs if something's wrong.
 */
void verifyACLs()
{
    //verification of ACLs
    //There must not exist more ACLs with same name and different type
    integer i = 0;
    list<string> tested = [];
    list<integer> to_remove = [];
    integer ii = 0;
    foreach (map<string,any> value, acls,
        {
            if (!contains(tested, value["name"]:"")){
                if (NumACLs(i) > 0){
                    to_remove = [];
                    ii = 0;
                    foreach (map<string,any> val, acls,
                        {
                            if (val["name"]:"" == value["name"]:""
                                && val["type"]:"" != value["type"]:""){
                                to_remove = add(to_remove, ii);
                            }
                            ii = ii + 1;
                        });
                    //delete all ACLs which has not type same as value["type"]:"" -
                    // - it means type of first occurence of tested ACL
                    foreach (integer val, to_remove, { acls = remove(acls, val);});
                }
                tested = add(tested, value["name"]:"");
            }
            i = i + 1;
        });
}

/**
 * Read setting of parameter http_port.
 *      http_port [hostname:]port [transparent]
 *
 * return true on success
 */
boolean readHttpPorts()
{
    boolean ok = true;
    list tmp = [];
    list tmp2 = [];
    map <string,any> tmp_http_port = $[];

    http_ports = [];
    foreach (string value, (list<string>)SCR::Read(add(squid_path,"http_port")),
        {
            tmp_http_port = $[];
            tmp = [];
            tmp2 = [];

            tmp = split(value," \t");

            //can parse only 'http_port hostname:port [transparent]'
            if (size(tmp) < 1 || size(tmp) > 2){
                ok = false;
                return false;
            }

            // hostname and port
            tmp2 = split(tmp[0]:"",":");
            y2debug("readHttpPorts - tmp2: %1",tmp2);
            if (size(tmp2) == 1){
                tmp_http_port["host"] = "";
                tmp_http_port["port"] = tmp2[0]:"";
            }else{
                tmp_http_port["host"] = (string)tmp2[0]:"";
                tmp_http_port["port"] = tmp2[1]:"";
            }

            //transparent option
            if (size(tmp) == 2 && tmp[1]:"" == "transparent")
                tmp_http_port["transparent"] = true;

            http_ports = add(http_ports, tmp_http_port);
        });

    return ok;
}

/**
 * Read setting of parameter http_access.
 *      http_access allow acl1 !acl2 ...
 *
 * return true on success
 */
boolean readHttpAccesses()
{
    boolean ok = true;
    list tmp = [];
    map <string,any> tmp_http_access = $[];

    http_accesses = [];
    foreach (string value, (list<string>)SCR::Read( add(squid_path,"http_access")),
        {
            tmp_http_access = $[];

            tmp = split(value, " \t");

            if (tmp[0]:"" != "allow" && tmp[0]:"" != "deny"){
                ok = false;
                return false;
            }

            tmp_http_access["allow"] = (tmp[0]:"" == "allow" ? true : false);
            tmp_http_access["acl"] = remove(tmp, 0);

            http_accesses = add(http_accesses, tmp_http_access);
        });

    return ok;
}

/**
 * Read setting of parameter refresh_pattern.
 *      refresh_pattern [-i] regexp min percent max [options (ignored)]
 *
 * return true on success
 */
boolean readRefreshPatterns()
{
    boolean ok = true;
    list tmp = [];
    map <string,any> tmp_refresh_pattern = $[];

    refresh_patterns = [];
    foreach (string value, (list<string>)SCR::Read( add(squid_path, "refresh_pattern")),
        {
            tmp_refresh_pattern = $[];

            tmp = split(value, " \t");

            //case-insesitive
            if (tmp[0]:"" == "-i"){
                tmp_refresh_pattern["case_sensitive"] = false;
                tmp = remove(tmp, 0);
            }else{
                tmp_refresh_pattern["case_sensitive"] = true;
            }

            if (size(tmp) < 4){
                ok = false;
                return false;
            }

            tmp_refresh_pattern["regexp"] = tmp[0]:"";
            tmp_refresh_pattern["min"] = tmp[1]:"";
            tmp_refresh_pattern["percent"] = deletechars(tmp[2]:"","%");
            tmp_refresh_pattern["max"] = tmp[3]:"";

            refresh_patterns = add(refresh_patterns, tmp_refresh_pattern);
        });

    return ok;
}

/**
 * Read setting of parameter acl.
 *      acl aclname acltype string1 string2 ...
 *
 * return true on success
 */
boolean readACLs()
{
    boolean ok = true;
    list tmp = [];
    map <string, any> tmp_acl = $[];

    //list of types which contains regular expression
    list<string> regexps = [
        "srcdom_regex",
        "dstdom_regex",
        "url_regex",
        "urlpath_regex",
        "browser"
    ];

    acls = [];
    foreach (string value, (list<string>)SCR::Read( add(squid_path, "acl")),
        {
            tmp_acl = $[];

            tmp = split(value, " \t");

            if (size(tmp) < 3){
                ok = false;
                return false;
            }

            tmp_acl["name"] = tmp[0]:"";
            tmp_acl["type"] = tmp[1]:"";
            tmp_acl["options"] = remove(remove(tmp,0),0);

            // Special settings:
            // concat list of regular expressions into one option
            if (contains(regexps, tmp_acl["type"]:"")){
                if ((tmp_acl["options"]:[])[0]:"" == "-i"){
                    tmp_acl["options"] = ["-i", mergestring((list<string>)remove(tmp_acl["options"]:[], 0), " ")];
                }else{
                    tmp_acl["options"] = [mergestring(tmp_acl["options"]:[], " ")];
                }
            }else
            //format: acl aclname header_name [-i] list of regexps
            if(tmp_acl["type"]:"" == "req_header" || tmp_acl["type"]:"" == "rep_header"){
                if ((tmp_acl["options"]:[])[1]:"" == "-i"){
                    tmp_acl["options"] = [(tmp_acl["options"]:[])[0]:"",
                                          "-i",
                                          mergestring((list<string>)remove(remove(tmp_acl["options"]:[], 0), 0), " ")];
                }else{
                    tmp_acl["options"] = [(tmp_acl["options"]:[])[0]:"",
                                          mergestring((list<string>)remove(tmp_acl["options"]:[], 0), " ")];
                }
            }

            acls = add(acls, tmp_acl);
        });

    verifyACLs();

    return ok;
}

string repair_timeout_period_units(string old)
{
    string ret = "seconds";
    if (old == "day"){
        ret = "days";
    }else if (old == "hour"){
        ret = "hours";
    }else if (old == "minute"){
        ret = "minutes";
    }else if (old == "second"){
        ret = "seconds";
    }else if (contains(["seconds", "minutes", "hours", "days"], old)){
        ret = old;
    }

    return ret;
}
/**
 * Read rest of setting.
 * return true on success
 */
boolean readRestSetting()
{
    boolean ok = true;
    list tmp = [];

    settings = $[];
    foreach (string key, list value, parameters,
        {
            tmp = (list <string>)SCR::Read( add(squid_path, key));
            tmp = split(tmp[0]:"", " \t");

            if (size(tmp) > 0){
                settings[key] = tmp;
            }else{
                settings[key] = value;
            }

        });

    //special modification
    settings["cache_replacement_policy"] = [mergestring(settings["cache_replacement_policy"]:[]," ")];
    settings["memory_replacement_policy"] = [mergestring(settings["memory_replacement_policy"]:[]," ")];
    settings["connect_timeout"] = [ (settings["connect_timeout"]:[])[0]:"",
                                    repair_timeout_period_units((settings["connect_timeout"]:[])[1]:"") ];
    settings["client_lifetime"] = [ (settings["client_lifetime"]:[])[0]:"",
                                    repair_timeout_period_units((settings["client_lifetime"]:[])[1]:"") ];

    return ok;
}

/**
 * Read all squid settings
 * @return true on success
 */
global boolean Read() {
    boolean ok = true;

    Progress::New(_("Initializing squid Configuration"),
                  " ",
                  5,
                  [_("Read the settings of Http Ports"),
                   _("Read the settings of Refresh Patterns"),
                   _("Read the settings of ACLs"),
                   _("Read the settings of Http Accesses"),
                   _("Read the rest settings")],
                  [_("Reading the setting ...")],
                  "");

    if(Abort()) return false;
    Progress::NextStage();

    if (!readHttpPorts()) ok = false;
    Progress::NextStage();

    if (!readRefreshPatterns()) ok = false;
    Progress::NextStage();

    if (!readACLs()) ok = false;
    Progress::NextStage();

    if (!readHttpAccesses()) ok = false;
    Progress::NextStage();

    if (!readRestSetting()) ok = false;
    Progress::NextStage();

    y2debug("================ Setting ======================");
    y2debug("Squid::Read - http_ports: %1",http_ports);
    y2debug("Squid::Read - http_accesses: %1", http_accesses);
    y2debug("Squid::Read - acls: %1", acls);
    y2debug("Squid::Read - refresh_patterns: %1", refresh_patterns);
    y2debug("Squid::Read - settings: %1", settings);
    y2debug("================ Setting END ==================");

    /* Error message */
    if(!ok) Report::Error(_("Cannot read configuration file."));

    return true;
}

/**
 * Write all squid settings
 * @return true on success
 */
global boolean Write() {

    /* Squid read dialog caption */
    string caption = _("Saving squid Configuration");

    // TODO FIXME And set the right number of stages
    integer steps = 2;

    integer sl = 500;
    sleep(sl);

    // TODO FIXME Names of real stages
    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    /* Progress stage 1/2 */
	    _("Write the settings"),
	    /* Progress stage 2/2 */
	    _("Run SuSEconfig")
	], [
	    /* Progress step 1/2 */
	    _("Writing the settings..."),
	    /* Progress step 2/2 */
	    _("Running SuSEconfig..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // write settings
    if(Abort()) return false;
    Progress::NextStage();
    /* Error message */
    if(false) Report::Error (_("Cannot write settings."));
    sleep(sl);

    // run SuSEconfig
    if(Abort()) return false;
    Progress::NextStage ();
    /* Error message */
    if(false) Report::Error (Message::SuSEConfigFailed());
    sleep(sl);

    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();
    sleep(sl);

    if(Abort()) return false;
    return true;
}

/**
 * Get all squid settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings) {
    // TODO FIXME: your code here (fill the above mentioned variables)...
    return true;
}

/**
 * Dump the squid settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
    // TODO FIXME: your code here (return the above mentioned variables)...
    return $[];
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list Summary() {
    // TODO FIXME: your code here...
    /* Configuration summary text for autoyast */
    return [ _("Configuration summary..."), [] ];
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global list Overview() {
    // TODO FIXME: your code here...
    return [];
}

/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages() {
    // TODO FIXME: your code here...
    return $[ "install":[], "remove":[] ];
}

/* EOF */
}
/* vim: set sw=4 ts=4 et ft=ycp : */
