/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	include/squid/complex.ycp
 * Package:	Configuration of squid
 * Summary:	Dialogs definitions
 * Authors:	Daniel Fiser <dfiser@suse.cz>
 *
 * $Id: complex.ycp 29363 2006-03-24 08:20:43Z mzugec $
 */

{

textdomain "squid";

import "Label";
import "Popup";
import "Wizard";
import "Wizard_hw";
import "Confirm";
import "Report";

import "Squid";
import "SquidACL";
import "SquidErrorMessages";


include "squid/helps.ycp";




/**
 * Return a modification status
 * @return true if data was modified
 */
boolean Modified() {
    return Squid::Modified();
}

boolean ReallyAbort() {
    return !Squid::Modified() || Popup::ReallyAbort(true);
}

boolean PollAbort() {
    return UI::PollInput() == `abort;
}

/**
 * Read settings dialog
 * @return `abort if aborted and `next otherwise
 */
symbol ReadDialog() {
    Wizard::RestoreHelp(HELPS["read"]:"");
    // Squid::AbortFunction = PollAbort;
    //if (!Confirm::MustBeRoot()) return `abort;
    boolean ret = Squid::Read();
    return ret ? `next : `abort;
}

/**
 * Write settings dialog
 * @return `abort if aborted and `next otherwise
 */
symbol WriteDialog() {
    Wizard::RestoreHelp(HELPS["write"]:"");
    // Squid::AbortFunction = PollAbort;
    boolean ret = Squid::Write();
    return ret ? `next : `abort;
}



/*********************   INITS   *****************/
/**
 * Do simple initialization of dialog.
 * Given map has to be in form:
 *      $[ id_of_widget : value_on_which_has_to_be_set,
 *         ....
 *       ]
 */
void simpleInit(map<string,any> m)
{
    foreach(string key, any value, m,
        {
            UI::ChangeWidget(`id(key), `Value, value);
        });
}



void InitHttpPortsTable()
{
    list items = [];
    integer i = 0;

    foreach(map<string,any> value, Squid::GetHttpPorts(),
        {
            items = add(items, `item(`id(i), value["host"]:"", value["port"]:"",
                                      (value["transparent"]:false ? "transparent" : "")));
            i = i+1;
        });

    y2debug("complex::InitPortsTable() - items: %1, http_ports: %2", items, Squid::GetHttpPorts());
    UI::ChangeWidget(`id("http_port"), `Items, items);
    if (size(items) > 0){
        UI::ChangeWidget(`id(`edit), `Enabled, true);
        UI::ChangeWidget(`id(`del), `Enabled, true);
    }else{
        UI::ChangeWidget(`id(`edit), `Enabled, false);
        UI::ChangeWidget(`id(`del), `Enabled, false);
    }
}
void InitAddEditHttpPortDialog(integer id_item)
{
    if (id_item != nil){
        map<string,any> values = Squid::GetHttpPort(id_item);

        UI::ChangeWidget(`id("host"), `Value, values["host"]:"");
        UI::ChangeWidget(`id("port"), `Value, values["port"]:"");
        UI::ChangeWidget(`id("transparent"), `Value, values["transparent"]:false);
    }
}

void InitRefreshPatternsTable()
{
    list items = [];
    integer i = 0;

    foreach (map<string,any> value, Squid::GetRefreshPatterns(),
        {
            items = add(items, `item(`id(i), value["regexp"]:"", value["min"]:"",
                        value["percent"]:"", value["max"]:""));

            i = i+1;
        });

    y2debug("complex::InitRefreshPatternsTable() - items: %1", items);
    UI::ChangeWidget(`id("refresh_patterns"), `Items, items);
    if (size(items) > 0){
        UI::ChangeWidget(`id(`edit), `Enabled, true);
        UI::ChangeWidget(`id(`del), `Enabled, true);
        UI::ChangeWidget(`id(`up), `Enabled, true);
        UI::ChangeWidget(`id(`down), `Enabled, true);
    }else{
        UI::ChangeWidget(`id(`edit), `Enabled, false);
        UI::ChangeWidget(`id(`del), `Enabled, false);
        UI::ChangeWidget(`id(`up), `Enabled, false);
        UI::ChangeWidget(`id(`down), `Enabled, false);
    }
}
void InitAddEditRefreshPatternDialog(integer id_item)
{
    if (id_item != nil){
        map<string,any> values = Squid::GetRefreshPattern(id_item);

        UI::ChangeWidget(`id("regexp"), `Value, values["regexp"]:"");
        UI::ChangeWidget(`id("min"), `Value, tointeger(values["min"]:""));
        UI::ChangeWidget(`id("percent"), `Value, tointeger(values["percent"]:""));
        UI::ChangeWidget(`id("max"), `Value, tointeger(values["max"]:""));
        UI::ChangeWidget(`id("regexp_case_insensitive"), `Value, !values["case_sensitive"]:true);

        y2debug("complex::InitAddEditRefreshPatternDialog() - values: %1",values);
    }
}

void InitCache2Dialog()
{
    map<string, list> set = (map<string, list>)Squid::GetSettings();
    simpleInit($[
        "cache_mem" : tointeger((set["cache_mem"]:[])[0]:""),
        "cache_mem_units" : (set["cache_mem"]:[])[1]:"",
        "cache_max_object_size" : tointeger((set["maximum_object_size"]:[])[0]:""),
        "cache_max_object_size_units" : (set["maximum_object_size"]:[])[1]:"",
        "cache_min_object_size" : tointeger((set["minimum_object_size"]:[])[0]:""),
        "cache_min_object_size_units" : (set["minimum_object_size"]:[])[1]:"",
        "cache_swap_low" : tointeger((set["cache_swap_low"]:[])[0]:""),
        "cache_swap_high" : tointeger((set["cache_swap_high"]:[])[0]:""),
        "cache_replacement_policy" : (set["cache_replacement_policy"]:[])[0]:"",
        "memory_replacement_policy" : (set["memory_replacement_policy"]:[])[0]:"",
        "cache_dir" : (set["cache_dir"]:[])[1]:""
    ]);
}
void InitCacheDirAdvancedSettingDialog()
{
    map<string, list> set = (map<string, list>)Squid::GetSettings();
    simpleInit($[
        //"type" : (set["cache_dir"]:[])[0]:"",
        "mbytes" : tointeger((set["cache_dir"]:[])[2]:""),
        "l1dirs" : tointeger((set["cache_dir"]:[])[3]:""),
        "l2dirs" : tointeger((set["cache_dir"]:[])[4]:"")
    ]);
}


void InitACLGroupsTable()
{
    list items = [];
    integer i = 0;
    list<string> sup_acls = SquidACL::SupportedACLs();

    foreach(map<string,any> value, Squid::GetACLs(),
        {
            // test, if know how to handle this ACL
            if (contains(sup_acls, value["type"]:"")){
                items = add(items, `item(`id(i), value["name"]:"", value["type"]:"",
                                         mergestring(value["options"]:[], " ")));
                i = i+1;
            }
        });

    UI::ChangeWidget(`id("acl"), `Items, items);
    if (size(items) > 0){
        UI::ChangeWidget(`id(`edit_acl), `Enabled, true);
        UI::ChangeWidget(`id(`del_acl), `Enabled, true);
    }else{
        UI::ChangeWidget(`id(`edit_acl), `Enabled, false);
        UI::ChangeWidget(`id(`del_acl), `Enabled, false);
    }
}
void InitHttpAccessTable()
{
    list items = [];
    integer i = 0;

    foreach(map<string,any> value, Squid::GetHttpAccesses(),
        {
            items = add(items, `item(`id(i), (value["allow"]:true ? "allow" : "deny"),
                                     mergestring(value["acl"]:[], " ")));
            i = i+1;
        });

    UI::ChangeWidget(`id("http_access"), `Items, items);
    if (size(items) > 0){
        UI::ChangeWidget(`id(`edit_http_access), `Enabled, true);
        UI::ChangeWidget(`id(`del_http_access), `Enabled, true);
        UI::ChangeWidget(`id(`up_http_access), `Enabled, true);
        UI::ChangeWidget(`id(`down_http_access), `Enabled, true);
    }else{
        UI::ChangeWidget(`id(`edit_http_access), `Enabled, false);
        UI::ChangeWidget(`id(`del_http_access), `Enabled, false);
        UI::ChangeWidget(`id(`up_http_access), `Enabled, false);
        UI::ChangeWidget(`id(`down_http_access), `Enabled, false);
    }
}


void InitAddEditHttpAccessDialog(integer id_item)
{
    list items = [];
    list acls_items = [];

    if (id_item != nil){
        map<string, any> http_access = Squid::GetHttpAccess(id_item);
        integer i = 0;

        foreach(string value, http_access["acl"]:[],
            {
                items = add(items, `item(`id(i), (search(value,"!")==0 ? "not" : ""), deletechars(value, "!")));
                i = i+1;
            });
        UI::ChangeWidget(`id("acls"), `Items, items);
        UI::ChangeWidget(`id("allow_deny"), `Value, (http_access["allow"]:true ? "allow" : "deny"));

        items = [];
    }

    foreach(term value, (list<term>)UI::QueryWidget(`id("acls"), `Items),
        {
            acls_items = add(acls_items, value[2]:"");
        });

    foreach(map<string,any> value, Squid::GetACLs(),
        {
            if (!contains(items, `item(`id(value["name"]:""), value["name"]:"")) &&
                !contains(acls_items, value["name"]:""))
                items = add(items, `item(`id(value["name"]:""), value["name"]:""));
        });
    UI::ChangeWidget(`id("acl"), `Items, items);
    UI::ChangeWidget(`id("acl_not"), `Value, false);
}


void InitAddEditACLDialog(integer id_item)
{
    if (id_item != nil){
        map<string,any> acl = Squid::GetACL(id_item);
        UI::ChangeWidget(`id("name"), `Value, acl["name"]:"");
        UI::ChangeWidget(`id("type"), `Value, acl["type"]:"");
    }
}


void InitLoggingFrame()
{
    map<string, list> set = (map<string, list>)Squid::GetSettings();
    simpleInit($[
        "access_log" : (set["access_log"]:[])[0]:"",
        "cache_log" : (set["cache_log"]:[])[0]:"",
        "cache_store_log" : (set["cache_store_log"]:[])[0]:"",

        "emulate_httpd_log" : ((set["emulate_httpd_log"]:[])[0]:"" == "on" ? true : false)
    ]);
}

void InitTimeoutsFrame()
{
    map<string, list> set = (map<string, list>)Squid::GetSettings();
    simpleInit($[
        "connect_timeout" : tointeger((set["connect_timeout"]:[])[0]:""),
        "connect_timeout_units" : (set["connect_timeout"]:[])[1]:"",
        "client_lifetime" : tointeger((set["client_lifetime"]:[])[0]:""),
        "client_lifetime_units" : (set["client_lifetime"]:[])[1]:""
    ]);
}


void InitMiscellaneousDialog()
{
    simpleInit($[
        "cache_mgr" : (Squid::GetSetting("cache_mgr"))[0]:"",
        "ftp_passive" : (Squid::GetSetting("ftp_passive"))[0]:"" == "on" ? true : false
    ]);
    UI::ChangeWidget(`id("error_language"), `Items, SquidErrorMessages::GetLanguagesToComboBox());
    UI::ChangeWidget(`id("error_language"), `Value, SquidErrorMessages::GetLanguageFromPath(
                                                        (Squid::GetSetting("error_directory"))[0]:""
                                                    ));
}
/*********************   INITS END  ****************/



/********************* STORING + DELETING ********************/
boolean StoreDataFromAddEditHttpPortDialog(integer id_item)
{
    boolean ok = true;
    string host = (string)UI::QueryWidget(`id("host"), `Value);
    string port = (string)UI::QueryWidget(`id("port"), `Value);
    boolean transparent = (boolean)UI::QueryWidget(`id("transparent"), `Value);

    if (size(port) > 0){
        if (id_item == nil){
            Squid::AddHttpPort(host, port, transparent);
        }else{
            Squid::ModifyHttpPort(id_item, host, port, transparent);
        }
    }else{
        Report::Error(_("Port number must not be empty."));
        ok = false;
    }

    return ok;
}

integer DelFromHttpPortsTable(integer id_item)
{
    Squid::DelHttpPort(id_item);
    if (id_item >= size(Squid::GetHttpPorts())){
        id_item = id_item - 1;
    }
    return id_item;
}

boolean StoreDataFromAddEditRefreshPatternDialog(integer id_item)
{
    boolean ok = true;
    string regexp = (string)UI::QueryWidget(`id("regexp"), `Value);
    string min = tostring(UI::QueryWidget(`id("min"), `Value));
    string percent = tostring(UI::QueryWidget(`id("percent"), `Value));
    string max = tostring(UI::QueryWidget(`id("max"), `Value));
    boolean case_sensitive = !(boolean)UI::QueryWidget(`id("regexp_case_insensitive"), `Value);

    if (size(regexp) > 0){
        if (id_item == nil){
            Squid::AddRefreshPattern(regexp, min, percent, max, case_sensitive);
        }else{
            Squid::ModifyRefreshPattern(id_item, regexp, min, percent, max, case_sensitive);
        }
    }else{
        Report::Error(_("Regular expression must not be empty."));
        ok = false;
    }

    return ok;
}

integer DelFromRefreshPatternsTable(integer id_item)
{
    Squid::DelRefreshPattern(id_item);
    if (id_item >= size(Squid::GetRefreshPatterns())){
        id_item = id_item - 1;
    }
    return id_item;
}

/**
 * returns new position or nil if not moved
 */
integer MoveUpRefreshPattern(integer id_item)
{
    integer ret = nil;

    if (id_item > 0){
        Squid::MoveRefreshPattern(id_item, id_item - 1);
        ret = id_item - 1;
    }
    return ret;
}
/**
 * returns new position or nil if not moved
 */
integer MoveDownRefreshPattern(integer id_item)
{
    integer ret = nil;

    if (id_item < size(Squid::GetRefreshPatterns())-1){
        Squid::MoveRefreshPattern(id_item, id_item + 1);
        ret = id_item + 1;
    }
    return ret;
}


boolean StoreDataFromCacheDirAdvancedSettingDialog()
{
    list set = Squid::GetSetting("cache_dir");
    Squid::SetSetting("cache_dir",
            [set[0]:"",
             set[1]:"",
             tostring(UI::QueryWidget(`id("mbytes"), `Value)),
             tostring(UI::QueryWidget(`id("l1dirs"), `Value)),
             tostring(UI::QueryWidget(`id("l2dirs"), `Value))]);
    return true;
}
boolean StoreDataFromCache2Dialog()
{
    boolean ok = true;

    string cache_dir = (string)UI::QueryWidget(`id("cache_dir"), `Value);

    if (size(cache_dir) > 0){
        list set = Squid::GetSetting("cache_dir");

        Squid::SetSetting("cache_dir", [set[0]:"", cache_dir, set[1]:"", set[2]:"", set[3]:""]);
        Squid::SetSetting("cache_mem", [tostring(UI::QueryWidget(`id("cache_mem"), `Value)),
                                        UI::QueryWidget(`id("cache_mem_units"), `Value)]);
        Squid::SetSetting("maximum_object_size", [tostring(UI::QueryWidget(`id("cache_max_object_size"), `Value)),
                                                  UI::QueryWidget(`id("cache_max_object_size_units"), `Value)]);
        Squid::SetSetting("minimum_object_size", [tostring(UI::QueryWidget(`id("cache_min_object_size"), `Value)),
                                                  UI::QueryWidget(`id("cache_min_object_size_units"), `Value)]);
        Squid::SetSetting("cache_swap_low", [tostring(UI::QueryWidget(`id("cache_swap_low"), `Value))]);
        Squid::SetSetting("cache_swap_high", [tostring(UI::QueryWidget(`id("cache_swap_high"), `Value))]);
        Squid::SetSetting("cache_replacement_policy", [UI::QueryWidget(`id("cache_replacement_policy"), `Value)]);
        Squid::SetSetting("memory_replacement_policy", [UI::QueryWidget(`id("memory_replacement_policy"), `Value)]);
    }else{
        ok = false;
        Report::Error(_("Cache directory must not be empty."));
    }

    return ok;
}


boolean StoreDataFromAddEditHttpAccessDialog(integer id_item)
{
    boolean ok = true;
    boolean allow = true;
    list<string> acls = [];
    string tmp = "";

    allow = (UI::QueryWidget(`id("allow_deny"), `Value) == "allow" ? true : false);
    foreach(term value, (list<term>)UI::QueryWidget(`id("acls"), `Items),
        {
            tmp = (value[1]:"" == "not" ? "!" : "");
            tmp = tmp + value[2]:"";
            acls = add(acls, tmp);
        });

    if (size(acls) > 0){
        if (id_item == nil){
            Squid::AddHttpAccess(allow, acls);
        }else{
            Squid::ModifyHttpAccess(id_item, allow, acls);
        }
   }else{
       ok = false;
       Report::Error(_("ACL table must not be empty."));
   }

    return ok;
}
integer DelFromHttpAccessTable(integer id_item)
{
    Squid::DelHttpAccess(id_item);
    if (id_item >= size(Squid::GetHttpAccesses())){
        id_item = id_item - 1;
    }
    return (id_item);
}
integer MoveUpHttpAccess(integer id_item)
{
    integer ret = nil;

    if (id_item > 0){
        Squid::MoveHttpAccess(id_item, id_item - 1);
        ret = id_item - 1;
    }
    return ret;
}
integer MoveDownHttpAccess(integer id_item)
{
    integer ret = nil;

    if (id_item < size(Squid::GetHttpAccesses())-1){
        Squid::MoveHttpAccess(id_item, id_item + 1);
        ret = id_item + 1;
    }
    return ret;
}


boolean StoreDataFromAddEditACLDialog(integer id_item)
{
    boolean ok = true;
    string type = (string)UI::QueryWidget(`id("type"), `Value);
    string name = (string)UI::QueryWidget(`id("name"), `Value);
    list<string> options = [];
    boolean verification = SquidACL::Verify(type);

    if (verification && size(name) > 0){
        options = SquidACL::GetOptions(type);

        if (id_item == nil){
            Squid::AddACL(name, type, options);
        }else{
            string old_name = (Squid::GetACL(id_item))["name"]:"";
            if (old_name != name && Squid::NumACLs(id_item) == 1){
                list<string> affected_options = Squid::ACLIsUsedBy(id_item);
                if (size(affected_options) > 0 && contains(affected_options, "http_access")){
                    Report::Error( _("You can not change name of this ACL Group, because \nit's used in Access Control table."));
                    ok = false;
                }else if (size(affected_options) > 0){
                    if (!Report::AnyQuestion(Label::WarningMsg(),
                                             _("If you change name of this ACL Group these options might be affected: \n")
                                             + "    " + mergestring(affected_options, ",\n    ") + ".\n",
                                             _("Change name anyway"),
                                             _("Do not change name"),
                                             `focus_no)){
                        ok = false;
                    }
                }
            }
            if (ok){
                Squid::ModifyACL(id_item, name, type, options);
            }
        }
    }else if(verification){ // -> size(name) <= 0
        ok = false;
        Report::Error( _("Name must not be empty."));
    }else{
        ok = false;
    }

    return ok;
}

/**
 * Delete ACL with id id_item.
 * If ACL has only one occurence (one definition line) in config file and
 * ACL is used by any option (http_access, no_cache ...) than user is asked
 * if he really want to delete the ACL. If option 'http_access' uses this ACL
 * than it's declined to delete the ACL.
 */
integer DelFromACLGroupsTable(integer id_item)
{
    boolean ok = true;

    if (Squid::NumACLs(id_item) == 1){
        list<string> affected_options = Squid::ACLIsUsedBy(id_item);
        if (size(affected_options) > 0){
            ok = false;

            if (contains(affected_options, "http_access")){
                //Report::Error( _("This ACL Group can't be deleted.\nIt's used in Access Control table."));
                Report::Error( _("You must not delete this ACL Group, because \nit's used in Access Control table."));
            }else{
                string message = _("If you delete this ACL Group these options might be affected: \n")
                                 + "    " + mergestring(affected_options, ",\n    ") + ".\n";// +
                                 //_("Are you sure you want to delete this ACL Group?");
                if (Report::AnyQuestion(Label::WarningMsg(),
                                        message,
                                        _("Delete anyway"), //Label::YesButton(),
                                        _("Do not delete"), //Label::NoButton(),
                                        `focus_no)){
                    ok = true;
                }
            }
        }
    }

    if (ok){
        Squid::DelACL(id_item);
        if (id_item >= size(Squid::GetACLs())){
            id_item = id_item - 1;
        }
    }

    return id_item;
}




//TODO: Here must be control, if is possible to create each log file (if it's not
//      possible it causes breakdown of squid).
boolean StoreDataFromLoggingFrame()
{
    boolean ok = true;
    string message = "";
    string access_log = (string)UI::QueryWidget(`id("access_log"), `Value);
    string cache_log = (string)UI::QueryWidget(`id("cache_log"), `Value);
    string cache_store_log = (string)UI::QueryWidget(`id("cache_store_log"), `Value);
    string emulate_httpd_log = ((boolean)UI::QueryWidget(`id("emulate_httpd_log"), `Value)
                                ? "on" : "off");

    if (size(access_log) == 0){
        ok = false;
        message = message + (size(message)>0 ? "\n" : "") + _("Access Log must not be empty.");
    }
    if (size(cache_log) == 0){
        ok = false;
        message = message + (size(message)>0 ? "\n" : "") + _("Cache Log must not be empty.");
    }
    if (size(cache_store_log) == 0){
        ok = false;
        message = message + (size(message)>0 ? "\n" : "") + _("Cache Store Log must not be empty.");
    }

    if (ok){
        list<string> tmp = Squid::GetSetting("access_log");
        Squid::SetSetting("access_log", prepend(remove(tmp, 0), access_log));
        Squid::SetSetting("cache_log", [cache_log]);
        Squid::SetSetting("cache_store_log", [cache_store_log]);
        Squid::SetSetting("emulate_httpd_log", [emulate_httpd_log]);
    }else{
        Report::Error(message);
    }

    return ok;
}

boolean StoreDataFromTimeoutsFrame()
{
    Squid::SetSetting("connect_timeout", [tostring(UI::QueryWidget(`id("connect_timeout"), `Value)),
                                          (string)UI::QueryWidget(`id("connect_timeout_units"), `Value)]);
    Squid::SetSetting("client_lifetime", [tostring(UI::QueryWidget(`id("client_lifetime"), `Value)),
                                          (string)UI::QueryWidget(`id("client_lifetime_units"), `Value)]);
    return true;
}


boolean StoreDataFromMiscellaneousDialog()
{
    string error_language = (string)UI::QueryWidget(`id("error_language"), `Value);
    string cache_mgr = (string)UI::QueryWidget(`id("cache_mgr"), `Value);
    string ftp_passive = (boolean)UI::QueryWidget(`id("ftp_passive"), `Value) ? "on" : "off";

    Squid::SetSetting("error_directory",[SquidErrorMessages::GetPath(error_language)]);
    Squid::SetSetting("cache_mgr", [cache_mgr]);
    Squid::SetSetting("ftp_passive", [ftp_passive]);

    return true;
}
/********************* STORING + DELETING END ********************/

}
/* vim: set sw=4 ts=4 et ft=ycp : */
