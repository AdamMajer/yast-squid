/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	include/squid/complex.ycp
 * Package:	Configuration of squid
 * Summary:	Dialogs definitions
 * Authors:	Daniel Fiser <dfiser@suse.cz>
 *
 * $Id: complex.ycp 29363 2006-03-24 08:20:43Z mzugec $
 */

{

textdomain "squid";

import "Label";
import "Popup";
import "Wizard";
import "Wizard_hw";
import "Confirm";
import "Squid";


include "squid/helps.ycp";




/**
 * Return a modification status
 * @return true if data was modified
 */
boolean Modified() {
    return Squid::Modified();
}

boolean ReallyAbort() {
    return !Squid::Modified() || Popup::ReallyAbort(true);
}

boolean PollAbort() {
    return UI::PollInput() == `abort;
}

/**
 * Read settings dialog
 * @return `abort if aborted and `next otherwise
 */
symbol ReadDialog() {
    Wizard::RestoreHelp(HELPS["read"]:"");
    // Squid::AbortFunction = PollAbort;
    //if (!Confirm::MustBeRoot()) return `abort;
    boolean ret = Squid::Read();
    return ret ? `next : `abort;
}

/**
 * Write settings dialog
 * @return `abort if aborted and `next otherwise
 */
symbol WriteDialog() {
    Wizard::RestoreHelp(HELPS["write"]:"");
    // Squid::AbortFunction = PollAbort;
    boolean ret = Squid::Write();
    return ret ? `next : `abort;
}



/* Inits */
void InitHttpPortsTable()
{
    list items = [];
    integer i = 0;

    foreach(map<string,any> value, Squid::GetHttpPorts(),
        {
            items = add(items, `item(`id(i), value["host"]:"", value["port"]:"",
                                      (value["transparent"]:false ? "transparent" : "")));
            i = i+1;
        });

    y2debug("complex::InitPortsTable() - items: %1, http_ports: %2", items, Squid::GetHttpPorts());
    UI::ChangeWidget(`id("http_port"), `Items, items);
    if (size(items) > 0){
        UI::ChangeWidget(`id(`edit), `Enabled, true);
        UI::ChangeWidget(`id(`del), `Enabled, true);
    }else{
        UI::ChangeWidget(`id(`edit), `Enabled, false);
        UI::ChangeWidget(`id(`del), `Enabled, false);
    }
}
void InitAddEditHttpPortDialog(integer id_item)
{
    if (id_item != nil){
        map<string,any> values = Squid::GetHttpPort(id_item);

        UI::ChangeWidget(`id("host"), `Value, values["host"]:"");
        UI::ChangeWidget(`id("port"), `Value, values["port"]:"");
        UI::ChangeWidget(`id("transparent"), `Value, values["transparent"]:false);
    }
}



/* Storing */
void StoreDataFromAddEditHttpPortDialog(integer id_item)
{
    map <string, any> data = $[
        "host" : UI::QueryWidget(`id("host"), `Value),
        "port" : UI::QueryWidget(`id("port"), `Value),
        "transparent" : UI::QueryWidget(`id("transparent"), `Value)
    ];
    y2debug("complex::StoreDataFromAddEditHttpPortDialog() - data: %1",data);

    //Add
    if (id_item == nil){
        Squid::AddHttpPort(data);
    }else{
        Squid::ModifyHttpPort(id_item, data);
    }
}

void DelFromHttpPortsDialog(integer id_item)
{
    Squid::DelHttpPort(id_item);
}
}
/* vim: set sw=4 ts=4 et ft=ycp : */
